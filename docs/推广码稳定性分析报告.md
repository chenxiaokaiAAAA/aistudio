# 推广码稳定性分析报告

## 当前问题分析

### 1. 现有推广码生成机制
- **前端生成**：基于设备信息或随机生成用户ID和推广码
- **后端存储**：将用户ID和推广码存储到数据库
- **小程序码**：使用 `p={promotionCode}&u={userId}` 作为scene参数

### 2. 存在的问题
1. **设备依赖**：用户更换设备后推广码会变化
2. **版本更新**：小程序版本更新可能导致本地存储丢失
3. **删除重装**：用户删除小程序后推广码会重新生成
4. **不唯一性**：不同设备可能生成相同的推广码

## 解决方案设计

### 1. 基于微信OpenID的稳定绑定

#### 核心思路
- 使用微信OpenID作为唯一标识
- OpenID在同一个微信用户下是永久不变的
- 基于OpenID生成稳定的用户ID和推广码

#### 技术实现

##### 后端修改
1. **新增OpenID获取接口**（已存在）
   ```python
   @app.route('/api/user/openid', methods=['POST'])
   def get_user_openid():
       # 通过code获取openid
   ```

2. **修改用户注册逻辑**
   ```python
   def generate_stable_promotion_code(openid):
       """基于OpenID生成稳定的推广码"""
       import hashlib
       hash_obj = hashlib.md5(openid.encode())
       promotion_code = 'PET' + hash_obj.hexdigest()[:5].upper()
       return promotion_code
   
   def generate_stable_user_id(openid):
       """基于OpenID生成稳定的用户ID"""
       import hashlib
       hash_obj = hashlib.md5(openid.encode())
       user_id = 'USER' + hash_obj.hexdigest()[:10].upper()
       return user_id
   ```

3. **修改用户注册接口**
   - 优先使用OpenID生成用户信息
   - 如果OpenID已存在，直接返回现有用户信息
   - 确保同一OpenID对应唯一的推广码

##### 前端修改
1. **修改用户信息生成逻辑**
   ```javascript
   // 优先使用OpenID生成稳定信息
   function generateStableUserInfo() {
     return new Promise((resolve, reject) => {
       // 1. 尝试获取OpenID
       wx.login({
         success: (res) => {
           // 2. 调用后端获取OpenID
           wx.request({
             url: 'https://moeart.cc/api/user/openid',
             method: 'POST',
             data: { code: res.code },
             success: (openIdRes) => {
               const openid = openIdRes.data.openid;
               // 3. 基于OpenID生成稳定信息
               const { userId, promotionCode } = generateIdFromOpenId(openid);
               resolve({ userId, promotionCode });
             }
           });
         }
       });
     });
   }
   ```

2. **修改小程序启动逻辑**
   - 启动时优先尝试获取OpenID
   - 如果获取失败，使用降级方案
   - 确保推广码的稳定性

### 2. 数据库结构优化

#### 现有表结构
```sql
CREATE TABLE promotion_users (
    id INTEGER PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    promotion_code VARCHAR(20) UNIQUE NOT NULL,
    open_id VARCHAR(100),  -- 已存在
    nickname VARCHAR(100),
    avatar_url VARCHAR(200),
    total_earnings FLOAT DEFAULT 0.0,
    total_orders INTEGER DEFAULT 0,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

#### 优化建议
1. **添加唯一索引**
   ```sql
   CREATE UNIQUE INDEX idx_openid ON promotion_users(open_id);
   ```

2. **添加查询优化**
   ```sql
   CREATE INDEX idx_promotion_code ON promotion_users(promotion_code);
   ```

### 3. 兼容性处理

#### 现有用户迁移
1. **检测现有用户**
   - 查询没有OpenID的用户
   - 引导用户重新登录获取OpenID

2. **数据迁移策略**
   - 保留现有推广关系
   - 更新用户信息为基于OpenID的稳定信息
   - 确保推广码不变

#### 降级方案
1. **OpenID获取失败时**
   - 使用设备信息生成临时推广码
   - 提示用户重新登录
   - 记录日志便于排查

2. **网络异常时**
   - 使用本地缓存的用户信息
   - 网络恢复后同步到服务器

## 实施步骤

### 阶段1：后端API优化
1. 修改用户注册接口，支持OpenID优先
2. 添加OpenID查询接口
3. 优化推广码生成逻辑

### 阶段2：前端逻辑修改
1. 修改用户信息生成逻辑
2. 优化小程序启动流程
3. 添加错误处理和降级方案

### 阶段3：测试验证
1. 测试OpenID获取稳定性
2. 验证推广码唯一性
3. 测试设备更换和版本更新场景

### 阶段4：数据迁移
1. 迁移现有用户数据
2. 更新推广关系
3. 验证数据完整性

## 预期效果

### 1. 稳定性提升
- 用户推广码永久不变
- 设备更换不影响推广码
- 版本更新不影响用户身份

### 2. 唯一性保证
- 基于OpenID确保推广码唯一
- 避免重复推广码问题
- 提高数据准确性

### 3. 用户体验
- 用户无需重新生成推广码
- 推广关系持续有效
- 减少用户操作复杂度

## 风险评估

### 1. 技术风险
- OpenID获取失败的处理
- 网络异常时的降级方案
- 数据迁移的完整性

### 2. 业务风险
- 现有推广关系的影响
- 用户接受度
- 系统稳定性

### 3. 缓解措施
- 充分的测试验证
- 渐进式部署
- 完善的监控和日志
