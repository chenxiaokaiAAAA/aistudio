# 第十八批批量优化总结

**优化日期**: 2026-02-04  
**状态**: ✅ 已完成

---

## 🎯 优化目标

继续批量优化剩余接口的N+1查询问题和代码清理。

---

## ✅ 已优化接口

### 1. 加盟商订单详情页面代码清理 ✅

**文件**: `app/routes/franchisee/frontend.py` - `franchisee_order_detail()`

**问题**:
- 存在重复的代码块（610-621行），导致代码冗余和潜在错误

**优化前**:
```python
# 从批量查询的映射中获取图片（避免N+1查询）
images = order_images_map.get(order.id, [])
            images = []
            for img in order_images:
                # ... 重复的代码 ...
```

**优化后**:
```python
# 从批量查询的映射中获取图片（避免N+1查询）
images = order_images_map.get(order.id, [])
```

**优化效果**:
- 代码清理：移除重复代码
- 提高代码可维护性

---

### 2. 推广用户列表按访问数排序优化 ✅

**文件**: `app/routes/admin_promotion_api.py` - `get_admin_promotion_users()`

**问题**:
- 在循环中为每个用户执行3次查询（访问统计、订单统计、优惠券数量）
- N+1查询：1次查询用户 + N次查询访问统计 + N次查询订单统计 + N次查询优惠券数量
- 缺少分页支持（按访问数排序时）

**优化前**:
```python
users = PromotionUser.query.all()
for user in users:
    # 查询该用户的访问统计（N次查询）
    total_stats = db.session.execute(...).fetchone()
    # 查询用户自己的订单数、支付金额（N次查询）
    order_stats = db.session.execute(...).fetchone()
    # 查询用户优惠券数量（N次查询）
    coupon_count = db.session.execute(...).fetchone()
```

**优化后**:
```python
users = PromotionUser.query.all()

# 批量查询所有用户的访问统计（1次查询）
promotion_codes = [user.promotion_code for user in users if user.promotion_code]
visit_stats_map = {}
if promotion_codes:
    visit_stats = db.session.execute(
        db.text("SELECT final_promotion_code, COUNT(*) as total_visits FROM user_access_logs WHERE final_promotion_code IN :promotion_codes GROUP BY final_promotion_code"),
        {'promotion_codes': tuple(promotion_codes)}
    ).fetchall()
    visit_stats_map = {row[0]: row[1] for row in visit_stats}

# 批量查询所有用户的订单统计（1次查询）
open_ids = [user.open_id for user in users if user.open_id]
order_stats_map = {}
if open_ids:
    order_stats = db.session.execute(
        db.text("SELECT openid, COUNT(*) as paid_orders, COALESCE(SUM(price), 0) as total_paid_amount FROM orders WHERE openid IN :open_ids AND source_type = 'miniprogram' AND status IN (...) GROUP BY openid"),
        {'open_ids': tuple(open_ids)}
    ).fetchall()
    order_stats_map = {row[0]: {'paid_orders': row[1], 'total_paid_amount': float(row[2])} for row in order_stats}

# 批量查询所有用户的优惠券数量（1次查询）
user_ids = [user.user_id for user in users if user.user_id]
coupon_count_map = {}
if user_ids:
    coupon_counts = db.session.execute(
        db.text("SELECT user_id, COUNT(*) as coupon_count FROM user_coupons WHERE user_id IN :user_ids GROUP BY user_id"),
        {'user_ids': tuple(user_ids)}
    ).fetchall()
    coupon_count_map = {row[0]: row[1] for row in coupon_counts}

# 从批量查询的映射中获取数据（无额外查询）
for user in users:
    visit_stats_data = visit_stats_map.get(user.promotion_code, 0)
    order_stats_data = order_stats_map.get(user.open_id, {'paid_orders': 0, 'total_paid_amount': 0.0})
    coupon_count_data = coupon_count_map.get(user.user_id, 0)
    # ... 构建用户数据 ...

# 添加分页支持
total_users = len(user_list)
start_idx = (page - 1) * per_page
end_idx = start_idx + per_page
user_list = user_list[start_idx:end_idx]
```

**优化效果**:
- 查询次数：从 1 + 3N 次减少到 4 次
- 性能提升：预计 85-95%（当用户数量>10时）
- 添加分页支持：避免一次性加载所有用户数据

---

## 📊 优化统计

- **优化接口数**: 2个
- **解决N+1查询**: 1个
- **代码清理**: 1个
- **预计性能提升**: 85-95%（当数据量>10时）

---

## 🔄 下一步计划

继续查找和优化其他接口的N+1查询问题，重点关注：
1. 循环中的数据库查询
2. 缺少批量加载的关联数据查询
3. 缺少分页的大数据量查询
