# 第二十批批量优化总结

**优化日期**: 2026-02-04  
**状态**: ✅ 已完成

---

## 🎯 优化目标

继续批量优化剩余接口的N+1查询问题。

---

## ✅ 已优化接口

### 1. 用户佣金接口优化 ✅

**文件**: `app/routes/user_api/commission.py` - `get_user_commission()`

**问题**:
- 在循环中为每个佣金记录查询订单
- N+1查询：1次查询佣金 + N次查询订单

**优化前**:
```python
commissions = Commission.query.filter_by(referrer_user_id=user_id).order_by(Commission.create_time.desc()).all()

for commission in commissions:
    order = Order.query.filter_by(order_number=commission.order_id).first()  # N次查询
```

**优化后**:
```python
commissions = Commission.query.filter_by(referrer_user_id=user_id).order_by(Commission.create_time.desc()).all()

# 优化N+1查询：批量查询所有订单（1次查询）
order_numbers = [c.order_id for c in commissions if c.order_id]
orders_map = {}
if order_numbers:
    all_orders = Order.query.filter(Order.order_number.in_(order_numbers)).all()
    orders_map = {order.order_number: order for order in all_orders}

# 从批量查询的映射中获取（无额外查询）
for commission in commissions:
    order = orders_map.get(commission.order_id)
```

**优化效果**:
- 查询次数：从 1 + N 次减少到 2 次
- 性能提升：预计 80-90%（当佣金记录数量>10时）

---

### 2. 用户可用优惠券数量接口优化 ✅

**文件**: `app/routes/user_api/coupons.py` - `get_available_coupon_count()`

**问题**:
- 在循环中为每个优惠券查询用户已领取数量和总领取数量
- N+1查询：1次查询优惠券 + N次查询用户优惠券 + N次查询总领取数量

**优化前**:
```python
available_coupons = Coupon.query.filter(...).all()

for coupon in available_coupons:
    # 检查用户是否已经领取过（N次查询）
    user_coupon_count = UserCoupon.query.filter_by(
        user_id=user_id,
        coupon_id=coupon.id
    ).count()
    
    # 计算剩余数量（N次查询）
    claimed_count = UserCoupon.query.filter_by(coupon_id=coupon.id).count()
```

**优化后**:
```python
available_coupons = Coupon.query.filter(...).all()

# 优化N+1查询：批量查询用户已领取的优惠券数量和总领取数量（2次查询）
coupon_ids = [coupon.id for coupon in available_coupons]
user_coupon_counts_map = {}
claimed_counts_map = {}
if coupon_ids:
    from sqlalchemy import func
    # 批量查询用户已领取的优惠券数量（1次查询）
    user_coupon_counts = db.session.query(
        UserCoupon.coupon_id,
        func.count(UserCoupon.id).label('count')
    ).filter(
        UserCoupon.user_id == user_id,
        UserCoupon.coupon_id.in_(coupon_ids)
    ).group_by(UserCoupon.coupon_id).all()
    user_coupon_counts_map = {coupon_id: count for coupon_id, count in user_coupon_counts}
    
    # 批量查询所有优惠券的已领取数量（1次查询）
    claimed_counts = db.session.query(
        UserCoupon.coupon_id,
        func.count(UserCoupon.id).label('count')
    ).filter(
        UserCoupon.coupon_id.in_(coupon_ids)
    ).group_by(UserCoupon.coupon_id).all()
    claimed_counts_map = {coupon_id: count for coupon_id, count in claimed_counts}

# 从批量查询的映射中获取（无额外查询）
for coupon in available_coupons:
    user_coupon_count = user_coupon_counts_map.get(coupon.id, 0)
    claimed_count = claimed_counts_map.get(coupon.id, 0)
```

**优化效果**:
- 查询次数：从 1 + 2N 次减少到 3 次
- 性能提升：预计 85-95%（当优惠券数量>10时）

---

## 📊 优化统计

- **优化接口数**: 2个
- **解决N+1查询**: 2个
- **预计性能提升**: 80-95%（当数据量>10时）

---

## 🔄 下一步计划

继续查找和优化其他接口的N+1查询问题，重点关注：
1. 循环中的数据库查询
2. 缺少批量加载的关联数据查询
3. 缺少分页的大数据量查询
