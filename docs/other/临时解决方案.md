# 临时解决方案：兼容旧版本查询

## 问题分析

从日志可以看出：
1. 用户已成功注册：`USER0299405372`
2. 用户信息更新成功：`萌宠绘_8840`
3. 但订单查询失败：`phone=18350313107` 返回400错误

## 根本原因

前端代码仍在使用手机号查询，但后端已禁用此功能。

## 临时解决方案

为了不影响现有用户，我们可以添加一个临时的兼容接口，允许通过用户ID查询订单。

### 方案1：添加用户ID查询接口

```python
@app.route('/api/miniprogram/orders/by-userid', methods=['GET'])
def miniprogram_get_orders_by_userid():
    """通过用户ID查询订单（临时兼容接口）"""
    try:
        user_id = request.args.get('userId')
        
        if not user_id:
            return jsonify({'status': 'error', 'message': '缺少userId参数'}), 400
        
        # 通过用户ID查询订单
        orders = Order.query.filter(
            Order.source_type == 'miniprogram'
        ).order_by(Order.created_at.desc()).all()
        
        # 过滤出该用户的订单（通过openid匹配）
        user_orders = []
        for order in orders:
            if order.openid:
                # 通过openid反推用户ID
                user = PromotionUser.query.filter_by(open_id=order.openid).first()
                if user and user.user_id == user_id:
                    user_orders.append(order)
        
        print(f"用户 {user_id} 查询到 {len(user_orders)} 个订单")
        
        # 构建订单列表
        order_list = []
        for order in user_orders:
            # ... 构建订单数据 ...
            order_list.append({
                'orderId': order.order_number,
                'customerName': order.customer_name,
                'customerPhone': order.customer_phone,
                'status': order.status,
                # ... 其他字段 ...
            })
        
        return jsonify({
            'status': 'success',
            'orders': order_list
        })
        
    except Exception as e:
        return jsonify({'status': 'error', 'message': f'查询失败: {str(e)}'}), 500
```

### 方案2：修改现有接口支持用户ID

```python
@app.route('/api/miniprogram/orders', methods=['GET'])
def miniprogram_get_orders():
    """小程序获取订单列表 - 支持openid和userId查询"""
    try:
        openid = request.args.get('openid')
        user_id = request.args.get('userId')  # 新增：支持用户ID查询
        
        orders = []
        
        # 优先使用openid查询
        if openid:
            orders = Order.query.filter(
                Order.openid == openid,
                Order.source_type == 'miniprogram'
            ).order_by(Order.created_at.desc()).all()
            print(f"按openid查询到 {len(orders)} 个订单")
        
        # 如果没有openid，尝试通过用户ID查询
        elif user_id:
            # 先通过用户ID找到openid
            user = PromotionUser.query.filter_by(user_id=user_id).first()
            if user and user.open_id:
                orders = Order.query.filter(
                    Order.openid == user.open_id,
                    Order.source_type == 'miniprogram'
                ).order_by(Order.created_at.desc()).all()
                print(f"通过用户ID {user_id} 查询到 {len(orders)} 个订单")
            else:
                print(f"用户ID {user_id} 未找到对应的openid")
        
        # 如果都没有提供，返回错误
        if not openid and not user_id:
            return jsonify({'status': 'error', 'message': '缺少openid或userId参数'}), 400
        
        # ... 构建返回数据 ...
        
    except Exception as e:
        return jsonify({'status': 'error', 'message': f'查询失败: {str(e)}'}), 500
```

## 推荐方案

我推荐使用**方案2**，因为：
1. 保持API接口不变
2. 向后兼容现有前端代码
3. 逐步迁移到openid查询
4. 不影响用户体验

## 实施步骤

1. 修改后端接口，支持userId查询
2. 测试验证功能正常
3. 通知前端团队逐步迁移到openid
4. 最终移除userId查询支持

## 前端调用示例

```javascript
// 临时方案：使用用户ID查询
wx.request({
  url: 'https://photogooo/api/miniprogram/orders',
  data: {
    userId: 'USER0299405372'  // 使用用户ID
  },
  success: function(res) {
    console.log('订单查询成功:', res.data.orders);
  }
});

// 最终方案：使用openid查询
wx.request({
  url: 'https://photogooo/api/miniprogram/orders',
  data: {
    openid: userOpenId  // 使用openid
  },
  success: function(res) {
    console.log('订单查询成功:', res.data.orders);
  }
});
```

## 注意事项

1. 这是一个临时解决方案，最终还是要迁移到openid
2. 需要确保用户ID和openid的对应关系正确
3. 建议添加日志记录，便于问题排查
4. 考虑添加访问频率限制，防止滥用

