# 10台设备并发优化方案

## 📊 场景分析

### 业务场景
- **设备数量**：10台自拍机
- **并发提交**：同一时间可能提交10个任务
- **排队任务**：可能有40-50个任务排队
- **任务类型**：ComfyUI工作流 + 云端API调用

### 性能需求
- ✅ 支持10个并发任务提交
- ✅ 支持40-50个任务排队
- ✅ 稳定处理，不丢失任务
- ✅ 防止重复提交
- ✅ 限流保护（防止服务过载）

## ✅ 已实施的优化

### 1. 防重复提交机制
- ✅ 检查订单是否已有待处理/处理中的任务
- ✅ 如果已有任务，直接返回现有任务

### 2. 数据库锁机制
- ✅ 使用 `with_for_update()` 对订单和任务查询加锁
- ✅ 防止并发创建任务

### 3. 限流机制
- ✅ ComfyUI：最多10个并发调用（Semaphore）
- ✅ API：最多5个并发调用（Semaphore）

### 4. 任务队列系统（新增）
- ✅ 创建了 `app/services/task_queue_service.py`
- ✅ 支持任务排队（最大100个任务）
- ✅ 3个工作线程处理任务
- ✅ 自动启动队列服务

## 🔧 配置说明

### 任务队列配置

**文件**：`app/services/task_queue_service.py`

```python
# 队列配置
TASK_QUEUE = queue.Queue(maxsize=100)  # 最大100个任务排队
MAX_WORKERS = 3  # 最多3个工作线程处理任务
```

**配置建议**：
- **队列大小**：100个任务（足够处理40-50个排队任务）
- **工作线程数**：3个（根据服务器性能调整）
  - 如果服务器性能好，可以增加到5个
  - 如果服务器性能一般，保持3个

### 限流配置

**文件**：`app/services/workflow_service.py`

```python
COMFYUI_SEMAPHORE = Semaphore(10)  # 最多10个并发ComfyUI调用
```

**文件**：`app/services/ai_provider_service.py`

```python
API_SEMAPHORE = Semaphore(5)  # 最多5个并发API调用
```

**配置建议**：
- **ComfyUI并发数**：10个（适合10台设备同时提交）
- **API并发数**：5个（根据服务商限流调整）

## 📈 性能评估

### 10台设备同时提交（10个并发任务）

**处理流程**：
1. 10个任务同时提交到队列
2. 队列立即接收（队列大小100，足够）
3. 3个工作线程开始处理
4. 每个工作线程调用 `create_ai_task()`
5. `create_ai_task()` 内部有ComfyUI限流（10个并发）
6. 所有任务都能正常处理

**预计处理时间**：
- 队列接收：< 1秒
- 任务处理：根据ComfyUI处理时间（通常30秒-5分钟）
- 总处理时间：取决于最慢的任务

### 40-50个排队任务

**处理流程**：
1. 任务按顺序进入队列
2. 3个工作线程并发处理
3. 每个工作线程处理完一个任务后，立即处理下一个
4. 队列自动管理任务顺序

**预计处理时间**：
- 假设每个任务平均处理时间：2分钟
- 3个工作线程并发：40个任务 ≈ 27分钟（40 ÷ 3 × 2）
- 50个任务 ≈ 34分钟（50 ÷ 3 × 2）

## 🔍 监控和统计

### 队列统计信息

可以通过以下方式获取队列统计：

```python
from app.services.task_queue_service import get_queue_stats

stats = get_queue_stats()
print(stats)
# 输出：
# {
#     'total_submitted': 100,      # 总提交数
#     'total_processed': 95,       # 总处理数
#     'total_failed': 5,            # 总失败数
#     'current_queue_size': 5,     # 当前队列大小
#     'last_processed_time': ...,  # 最后处理时间
#     'queue_size': 5,              # 队列大小
#     'queue_maxsize': 100,        # 队列最大大小
#     'is_running': True,          # 是否运行中
#     'worker_count': 3            # 工作线程数
# }
```

## ⚙️ 配置调整建议

### 如果设备增加到20台

**需要调整**：
1. **ComfyUI并发数**：从10增加到15-20
   ```python
   COMFYUI_SEMAPHORE = Semaphore(20)  # 增加到20个并发
   ```

2. **工作线程数**：从3增加到5
   ```python
   MAX_WORKERS = 5  # 增加到5个工作线程
   ```

3. **队列大小**：保持100（足够）

### 如果排队任务增加到100+

**需要调整**：
1. **队列大小**：从100增加到200
   ```python
   TASK_QUEUE = queue.Queue(maxsize=200)  # 增加到200
   ```

2. **工作线程数**：从3增加到5-8
   ```python
   MAX_WORKERS = 8  # 增加到8个工作线程
   ```

## 🚨 注意事项

### 1. SQLite性能限制

如果并发量很大（>100任务/分钟），建议：
- 迁移到PostgreSQL或MySQL
- 配置数据库连接池

### 2. ComfyUI服务器性能

确保ComfyUI服务器能够处理：
- 10个并发任务
- 长时间运行（40-50个任务）

### 3. API服务商限流

不同服务商有不同的限流策略：
- 需要根据服务商文档调整 `API_SEMAPHORE` 的值
- 如果触发限流，任务会失败，需要重试

### 4. 任务失败处理

如果任务处理失败：
- 任务会记录失败状态
- 可以通过管理后台手动重试
- 建议实现自动重试机制（未来优化）

## 📝 测试建议

### 测试场景1：10台设备同时提交

```python
# 模拟10个任务同时提交
import threading
import time

def submit_task(order_id):
    from app.services.image_processing_service import process_order_images
    process_order_images(order_id=order_id, ...)

# 同时提交10个任务
threads = []
for i in range(10):
    t = threading.Thread(target=submit_task, args=(i+1,))
    threads.append(t)
    t.start()

# 等待所有任务完成
for t in threads:
    t.join()
```

**验证**：
- ✅ 所有任务都成功提交到队列
- ✅ 没有重复任务
- ✅ 任务按顺序处理

### 测试场景2：40-50个排队任务

```python
# 模拟40个任务排队
for i in range(40):
    submit_task(order_id=i+1)
    time.sleep(0.1)  # 间隔0.1秒提交

# 监控队列状态
from app.services.task_queue_service import get_queue_stats
stats = get_queue_stats()
print(f"队列大小: {stats['queue_size']}")
print(f"已处理: {stats['total_processed']}")
```

**验证**：
- ✅ 所有任务都进入队列
- ✅ 队列大小不超过100
- ✅ 任务按顺序处理
- ✅ 没有任务丢失

## 🎯 总结

### 当前优化状态

✅ **已完成**：
- 防重复提交机制
- 数据库锁机制
- 限流机制
- 任务队列系统

✅ **适用场景**：
- 10台设备同时提交 ✅
- 40-50个排队任务 ✅
- 中等并发场景 ✅

### 未来优化方向

⚠️ **如果设备继续增加**：
- 考虑使用Celery（分布式任务队列）
- 迁移到PostgreSQL/MySQL
- 增加服务器资源

---

**优化时间**：2025-01-XX  
**优化版本**：v1.0  
**适用场景**：10台设备，40-50个排队任务
